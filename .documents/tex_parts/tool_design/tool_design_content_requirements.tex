Software requirements, refer to the explicit delineations of the
functionalities a given system should offer, the scope of services it should
provide, and the operational constraints it must adhere to. There are two types
of requirements: Functional and Non-Functional, where the first focuses on what
a system is supposed to do and the latter on how a system is supposed to be
\cite{wiegers2013software}. We used the MoSCoW method to prioritise each
requirement, which is an acronym from the first letter of each prioritisation
category: Must have, Should have, Could have, Will not have
\cite{brennan2009guide}.

\begin{table}[!htb] \caption{Functional Requirements} \label{tab:functional-requirements}
  \begin{center}
    \begin{tabular}[c]{p{4em}|p{20em}|p{6em}}
      \textbf{ID} &
      \textbf{Requirement} &
      \textbf{Priority} \\
      \hline FR01 & Frontend allows for user selection of a tool. & {Must have} \\
      \hline FR02 & Frontend allows for user selection of a language. & {Must have} \\
      \hline FR03 & Frontend allows for user parameter tunning. & {Must have} \\
      \hline FR04 & Frontend allows for an user visualisation of the identified microservices. & {Must have} \\
      \hline FR05 & Frontend allows for user code upload (either source code or specification). & {Must have} \\
      \hline FR06 & Frontend allows comparison between multiple identifications. & {Must have} \\
      \hline FR07 & Frontend allows for user session. & {Should have} \\
      \hline FR08 & Frontend allows for download of output. & {Could have} \\
      \hline FR09 & Frontend allows for upload of previous outputs. & {Could have} \\
      \hline FR10 & Backend does not halt when an identification is running. & {Must have} \\
      \hline FR11 & Backend starts the identification as soon as the input is uploaded. & {Must have} \\
      \hline FR12 & Backend must serve the current existing approaches/languages/parameters to the user. & {Must have} \\
      \hline FR13 & Backend must signal the user when the identification is completed. & {Must have} \\
      \hline FR14 & Backend must signal the tool domain to start processing a code. & {Must have} \\
      \hline FR15 & Tool domain has at least one approach. & {Must have} \\
      \hline FR16 & Tool domain with each approach running separatly. & {Should have} \\
      \hline FR17 & Tool domain with extensible adapter for other approaches. & {Must have} \\
      \hline FR18 & Tool domain signals the backend when it finishes processing. & {Must have} \\
    \end{tabular}
  \end{center}
\end{table}

\begin{table}[!htb] \caption{Non-Functional Requirements} \label{tab:non-functional-requirements}
  \begin{center}
    \begin{tabular}[c]{p{4em}|p{20em}|p{6em}}
      \textbf{ID} &
      \textbf{Requirement} &
      \textbf{Priority} \\
      \hline NFR01 & Frontend must be deployed individually. & {Must have} \\
      \hline NFR02 & Frontend must be deployed using Docker. & {Must have} \\
      \hline NFR03 & Frontend could be split into multiple microservices. & {Could have} \\
      \hline NFR04 & Backend must be deployed individually. & {Must have} \\
      \hline NFR05 & Backend must be deployed using Docker. & {Must have} \\
      \hline NFR06 & Backend could be split into multiple microservices. & {Could have} \\
      \hline NFR07 & Tool domain should be deployed individually. & {Should have} \\
      \hline NFR08 & Each tool implementation deployed individually. & {Could have} \\
    \end{tabular}
  \end{center}
\end{table}

We delimited eighteen functional and eight non-functional requirements as an
initial Minimum Value Product (MVP), presented in
\Cref{tab:functional-requirements} and \Cref{tab:non-functional-requirements},
respectively. It is essential to highlight that no requirement fits the
\textit{"Will not have"} category because requirement elicitation was not
conducted with a user but rather a brainstorming between the entities
responsible for this work.
